## 1. main在执行前和执行后，会执行什么哪些代码？ 
- 之前：
  - 初始化系统相关资源，e.g. 设置栈指针，初始化变量，将未初始化的变量赋值等。
- 之后：
    - 执行析构函数（析构函数：析构函数用于在对象不再被使用时进行资源释放、清理和关闭操作。当一个对象的生命周期即将结束时，系统会自动调用其析构函数）也就是说析构函数用于对象的清理工作，比如关闭系统，释放内存，释放资源。
## 2. 结构体内存对齐问题
- 结构体内对齐： 指在计算机内存中存储结构体时，为了提高访问效率和内存访问速度，编译器通常会对结构体进行内存对齐操作。内存对齐是指将结构体中的成员按照特定规则排列在内存中，使得结构体成员的起始地址符合一定的对齐要求
- 总结一下： 
  - 结构体内部成员按声明顺序存储，第一个成员的地址和整体结构体地址相同
  - 未特殊说明时，按结构体中size最大的成员对齐
  - 内存对齐的好处包括提高访问效率、减少内存碎片和提高程序的可移植性
  
## 3. 指针和引用的区别
- 首先，引用是指用一个名称来引用一个变量，而不是直接操作变量本身。（主要是C/C++语言中的概念）
- 区别： 
  - 指针是一个变量，存储的是一个内存地址，但引用本质是变量，其实就是原变量的别名
  - 指针可以有多级，引用只能有一级（毕竟它只是一个外号）
  - 指针可以为NULL，并且在之后赋值。但是引用不可以，它必须在定义时初始化
  - 指针在初始化后可以改变指向，而引用在初始化之后不可再改变
  - sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小
  - 当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。
  - 引用本质是一个指针，同样会占4字节内存；指针是具体变量，需要占用存储空间（，具体情况还要具体分析）。
  - 引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。
  - 引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。
  - 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。

## 4.在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？
- 需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的
- 对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小
- 类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式
- 总的来说， 使用指针或引用作为函数参数的选择主要取决于是否需要修改原始值（指针）、参数的可选性（指针）、空指针异常的处理（指针）、不可变性（引用）和对象的大小（指针，引用都可）等因素。
## 5.堆和栈的区别
- 首先，堆和栈是计算机内存管理中的两种不同的数据区域。
- 分配方式：栈的内存分配由编译器自动进行，它使用一种称为"先进后出"（Last In First Out，LIFO）的方式进行管理。而堆的内存分配由程序员手动控制，通过调用动态内存分配函数（如malloc、new）来进行分配和释放。
- 内存管理：栈的内存管理是自动的，由编译器负责分配和释放栈帧（stack frame）中的变量。栈帧的大小是固定的，当函数执行结束时，栈帧中的变量会自动被释放。而堆的内存管理需要程序员显式地请求和释放内存，否则可能会导致内存泄漏。
- 存储对象类型：栈主要用于存储局部变量、函数参数和函数调用的上下文信息。存储在栈上的数据大小是确定的，通常较小。堆用于存储动态分配的内存，可以存储较大的数据对象。
- 内存访问速度：由于栈的内存分配和释放是编译器自动管理的，访问栈上的数据速度相对较快。而堆上的内存分配和释放需要手动控制，所以访问堆上的数据速度相对较慢。
- 生命周期：栈上的数据的生命周期与其所在的函数或代码块的执行时间相关，当函数或代码块执行结束时，栈上的数据会自动被释放。而堆上的数据的生命周期由程序员控制，需要手动分配和释放内存。
  
